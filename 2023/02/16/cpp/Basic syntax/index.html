<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Basic syntax | Ferry's blog</title><meta name="author" content="FerryChan"><meta name="copyright" content="FerryChan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="stringUser Input Stringscin considers a space (whitespace, tabs, etc) as a terminating character, which means that it can only display a single word (even if you type many words): 1234567string fullNa">
<meta property="og:type" content="article">
<meta property="og:title" content="Basic syntax">
<meta property="og:url" content="http://ferrychan666.github.io/2023/02/16/cpp/Basic%20syntax/index.html">
<meta property="og:site_name" content="Ferry&#39;s blog">
<meta property="og:description" content="stringUser Input Stringscin considers a space (whitespace, tabs, etc) as a terminating character, which means that it can only display a single word (even if you type many words): 1234567string fullNa">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://ferrychan666.github.io/img/Tom.jpg">
<meta property="article:published_time" content="2023-02-16T13:47:15.000Z">
<meta property="article:modified_time" content="2023-05-18T15:08:54.224Z">
<meta property="article:author" content="FerryChan">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ferrychan666.github.io/img/Tom.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Basic syntax",
  "url": "http://ferrychan666.github.io/2023/02/16/cpp/Basic%20syntax/",
  "image": "http://ferrychan666.github.io/img/Tom.jpg",
  "datePublished": "2023-02-16T13:47:15.000Z",
  "dateModified": "2023-05-18T15:08:54.224Z",
  "author": [
    {
      "@type": "Person",
      "name": "FerryChan",
      "url": "http://ferrychan666.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://ferrychan666.github.io/2023/02/16/cpp/Basic%20syntax/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Basic syntax',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/Tom.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">Basic syntax</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Basic syntax</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-02-16T13:47:15.000Z" title="Created 2023-02-16 21:47:15">2023-02-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-05-18T15:08:54.224Z" title="Updated 2023-05-18 23:08:54">2023-05-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="User-Input-Strings"><a href="#User-Input-Strings" class="headerlink" title="User Input Strings"></a>User Input Strings</h2><p><code>cin</code> considers a space (whitespace, tabs, etc) as a terminating character, which means that it can only display a single word (even if you type many words):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string fullName;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Type your full name: &quot;</span>;</span><br><span class="line">cin &gt;&gt; fullName;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Your name is: &quot;</span> &lt;&lt; fullName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type your full name: John Doe</span></span><br><span class="line"><span class="comment">// Your name is: John</span></span><br></pre></td></tr></table></figure>

<p>That’s why, when working with strings, we often use the <code>getline()</code> function to read a line of text. It takes <code>cin</code> as the first parameter, and the string variable as second:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string fullName;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Type your full name: &quot;</span>;</span><br><span class="line"><span class="built_in">getline</span> (cin, fullName);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Your name is: &quot;</span> &lt;&lt; fullName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type your full name: John Doe</span></span><br><span class="line"><span class="comment">// Your name is: John Doe</span></span><br></pre></td></tr></table></figure>

<h2 id="Omitting-Namespace"><a href="#Omitting-Namespace" class="headerlink" title="Omitting Namespace"></a>Omitting Namespace</h2><p>You might see some C++ programs that runs without the standard namespace library. The <code>using namespace std</code> line can be omitted and replaced with the <code>std</code> keyword, followed by the <code>::</code> operator for <code>string</code> (and <code>cout</code>) objects:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string greeting = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; greeting;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C风格"><a href="#C风格" class="headerlink" title="C风格"></a>C风格</h2><p>对于C风格的字符串，我们只用它进行输入，输出。</p>
<p>它本质是一个字符数组，以<code>\0</code>作为结束的标志</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br></pre></td></tr></table></figure>

<p>%s只能读取一个单词</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fgets</span>(str,<span class="number">100</span>,stdin);<span class="comment">//读取一整行，包括\n</span></span><br></pre></td></tr></table></figure>

<p>fgets()读取一整行，包括<code>\n</code></p>
<p>我们可以这样来读入不定数量的行，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fgets</span>(buf,<span class="number">200</span>,stdin) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        string str=buf;</span><br><span class="line">        <span class="comment">//干掉换行</span></span><br><span class="line">        str.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf) != EOF)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-风格"><a href="#C-风格" class="headerlink" title="C++风格"></a>C++风格</h2><p>下面的C++风格的字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>把字符串从c风格转换成c++风格：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str1=str;</span><br></pre></td></tr></table></figure>

<p>把字符串从c++风格转换成c风格：str1.c_str()	——&gt;printf()</p>
<p>连接：str1+”wrold”</p>
<p>删除：str1.erase(下标)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str<span class="number">1.</span><span class="built_in">erase</span>(str<span class="number">1.l</span>ength()<span class="number">-1</span>);<span class="comment">//把fget的最后一个元素\n干掉</span></span><br></pre></td></tr></table></figure>

<p>清空：str1.clear()</p>
<p>访问字符：str1[0]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str<span class="number">1.l</span>ength();i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器（指针）</span></span><br><span class="line"><span class="keyword">for</span>(string::iterator it=str<span class="number">1.</span><span class="built_in">begin</span>(); it!=str<span class="number">1.</span><span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>长度：str1.length()</p>
<p>判断相等：str1&#x3D;&#x3D;”hello”</p>
<p>比较字典序：str1&gt;”abandon”</p>
<p>查找子串：find()，找到返回子串起点下标，没有找到返回<code>string::npos</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;howareyou&quot;</span>;</span><br><span class="line"><span class="type">int</span> pos=str.<span class="built_in">find</span>(<span class="string">&quot;are&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(pos!=string::npos)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Found, position=%d\n&quot;</span>,pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切割字符串</p>
<p>substr(起始下标，子字符串长度)</p>
<p>substr(起始下标)，表示从起始下标到最后一个字符</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/c6ca566fa3984fae916e6d7beae8ea7f">https://www.nowcoder.com/questionTerminal/c6ca566fa3984fae916e6d7beae8ea7f</a><br>来源：牛客网</p>
<p>哈利波特在魔法学校的必修课之一就是学习魔咒。据说魔法世界有100000种不同的魔咒，哈利很难全部记住，但是为了对抗强敌，他必须在危急时刻能够调用任何一个需要的魔咒，所以他需要你的帮助。   给你一部魔咒词典。当哈利听到一个魔咒时，你的程序必须告诉他那个魔咒的功能；当哈利需要某个功能但不知道该用什么魔咒时，你的程序要替他找到相应的魔咒。如果他要的魔咒不在词典中，就输出“what?”                                        </p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先列出词典中不超过100000条不同的魔咒词条，每条格式为：</span><br><span class="line"></span><br><span class="line">[魔咒] 对应功能</span><br><span class="line"></span><br><span class="line">其中“魔咒”和“对应功能”分别为长度不超过20和80的字符串，字符串中保证不包含字符“[”和“]”，且“]”和后面的字符串之间有且仅有一个空格。词典最后一行以“@END@”结束，这一行不属于词典中的词条。</span><br><span class="line">词典之后的一行包含正整数N（&lt;=1000），随后是N个测试用例。每个测试用例占一行，或者给出“[魔咒]”，或者给出“对应功能”。</span><br></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个测试用例的输出占一行，输出魔咒对应的功能，或者功能对应的魔咒。如果魔咒不在词典中，就输出“what?”</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[expelliarmus] the disarming charm</span><br><span class="line">[rictusempra] send a jet of silver light to hit the enemy</span><br><span class="line">[tarantallegra] control the movement of one&#x27;s legs</span><br><span class="line">[serpensortia] shoot a snake out of the end of one&#x27;s wand</span><br><span class="line">[lumos] light the wand</span><br><span class="line">[obliviate] the memory charm</span><br><span class="line">[expecto patronum] send a Patronus to the dementors</span><br><span class="line">[accio] the summoning charm</span><br><span class="line">@END@</span><br><span class="line">4</span><br><span class="line">[lumos]</span><br><span class="line">the summoning charm</span><br><span class="line">[arha]</span><br><span class="line">take me to the sky</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">light the wand</span><br><span class="line">accio</span><br><span class="line">what?</span><br><span class="line">what?</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;string, string&gt; dict;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">char</span> line[<span class="number">200</span>];</span><br><span class="line">        <span class="built_in">fgets</span>(line, <span class="number">200</span>, stdin);</span><br><span class="line">        string str = line;</span><br><span class="line">        str.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">&quot;@END@&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string word = str.<span class="built_in">substr</span>(<span class="number">0</span>, str.<span class="built_in">find</span>(<span class="string">&#x27;]&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">        string info = str.<span class="built_in">substr</span>(str.<span class="built_in">find</span>(<span class="string">&#x27;]&#x27;</span>) + <span class="number">2</span>);</span><br><span class="line">        dict[word] = info;</span><br><span class="line">        dict[info] = word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="built_in">getchar</span>();          <span class="comment">//读取scanf留下的&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">char</span> line[<span class="number">200</span>];</span><br><span class="line">        <span class="built_in">fgets</span>(line,<span class="number">200</span>,stdin);</span><br><span class="line">        string str=line;</span><br><span class="line">        str.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dict.<span class="built_in">find</span>(str)!=dict.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,dict[str].<span class="built_in">c_str</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,dict[str].<span class="built_in">substr</span>(<span class="number">1</span>,dict[str].<span class="built_in">size</span>()<span class="number">-2</span>).<span class="built_in">c_str</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;what?\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="map-映射"><a href="#map-映射" class="headerlink" title="map(映射)"></a>map(映射)</h1><p>key——&gt;value</p>
<p>map&lt;key的类型，value的类型&gt;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; myMap;</span><br><span class="line">    <span class="keyword">if</span>(myMap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;myMap is empty!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用方括号[]插入</span></span><br><span class="line">    myMap[<span class="string">&quot;Caixukun&quot;</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//使用insert插入</span></span><br><span class="line">    myMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;Wuyifan&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizo of myMap = %d\n&quot;</span>,myMap.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//删除erase(), 参数为key</span></span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="string">&quot;Wuyifan&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizo of myMap = %d\n&quot;</span>,myMap.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    map&lt;string,string&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it=myMap.<span class="built_in">begin</span>();it!=myMap.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it-&gt;first=%s, it-&gt;second=%s\n&quot;</span>,it-&gt;first.<span class="built_in">c_str</span>(),it-&gt;second.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">it-&gt;first=Caixukun, it-&gt;second=ikun</span><br><span class="line">it-&gt;first=Wuyifan, it-&gt;second=meigeni</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//键 key--&gt; 值 value</span></span><br><span class="line">        <span class="comment">//&lt;键的类型,值的类型&gt;</span></span><br><span class="line">        map&lt;string,string&gt; myMap =&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Caixukun&quot;</span>,<span class="string">&quot;ikun&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Wuyifan&quot;</span>,<span class="string">&quot;meigeni&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        string name = str;</span><br><span class="line">        <span class="comment">//myMap[key]根据key映射到对应的值(C++风格的字符串)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s的粉丝被称为%s\n&quot;</span>,name.<span class="built_in">c_str</span>(),myMap[name].<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们的输出不是按照输入顺序输出的，因为map已经把元素按key的大小排号序了</p>
<p>描述</p>
<p>输入N个学生的信息，然后进行查询。</p>
<p>输入描述：</p>
<p>输入的第一行为N，即学生的个数(N&lt;&#x3D;1000) 接下来的N行包括N个学生的信息，信息格式如下： 01 李江 男 21 02 刘唐 男 23 03 张军 男 19 04 王娜 女 19 然后输入一个M(M&lt;&#x3D;10000),接下来会有M行，代表M次查询，每行输入一个学号，格式如下： 02 03 01 04</p>
<p>输出描述：</p>
<p>输出M行，每行包括一个对应于查询的学生的信息。 如果没有对应的学生信息，则输出“No Answer!”</p>
<p>示例1</p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">01 李江 男 21</span><br><span class="line">02 刘唐 男 23</span><br><span class="line">03 张军 男 19</span><br><span class="line">04 王娜 女 19</span><br><span class="line">5</span><br><span class="line">02</span><br><span class="line">03</span><br><span class="line">01</span><br><span class="line">04</span><br><span class="line">03</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">02 刘唐 男 23</span><br><span class="line">03 张军 男 19</span><br><span class="line">01 李江 男 21</span><br><span class="line">04 王娜 女 19</span><br><span class="line">03 张军 男 19</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; myMap;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="built_in">fgets</span>(buf,<span class="number">100</span>,stdin);</span><br><span class="line">        string str=buf;</span><br><span class="line">        str.<span class="built_in">pop_back</span>();</span><br><span class="line">        myMap[num]=str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="keyword">if</span>(myMap.<span class="built_in">find</span>(num)!=myMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02d%s\n&quot;</span>,num,myMap[num].<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No Answer!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="用map代替二分查找"><a href="#用map代替二分查找" class="headerlink" title="用map代替二分查找"></a>用map代替二分查找</h2><p>map的底层是一颗二叉搜索树（红黑树），所以，我们把数据插入到map是有序的。查找时间复杂度O(logn)</p>
<p>但，如果我们想要查找的时间复杂度达到O(1)，那么我们要用unorder_map，因为它的底层使用了hash散列</p>
<p>但这样做会使内存增大</p>
<p>先用map&lt;int,int&gt; 保存数组的值和下标，再用.find()方法</p>
<p>描述</p>
<p>输入数组长度 n 输入数组   a[1…n] 输入查找个数m 输入查找数字b[1…m]  输出 YES or NO 查找有则YES 否则NO </p>
<p>输入描述：</p>
<p>输入有多组数据。 每组输入n，然后输入n个整数，再输入m，然后再输入m个整数（1&lt;&#x3D;m,n&lt;&#x3D;100）。</p>
<p>输出描述：</p>
<p>如果在n个数组中输出YES否则输出NO。</p>
<p>示例1</p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 2 4 3</span><br><span class="line">3</span><br><span class="line">2 5 6</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;<span class="comment">//数组长度</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; findIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//读入n个元素</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line">        <span class="comment">//数组元素——&gt;key, 下标——&gt;value插入到map</span></span><br><span class="line">        findIndex[arr[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m;<span class="comment">//查找m个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> findNum;<span class="comment">//待查元素</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;findNum);</span><br><span class="line">        <span class="comment">//find函数会返回找到元素的指针，如果没有找到则返回尾后指针（最后元素的再后一个）</span></span><br><span class="line">        <span class="keyword">if</span>(findIndex.<span class="built_in">find</span>(findNum)==findIndex.<span class="built_in">end</span>())&#123;<span class="comment">//findIndex.end()返回尾后指针</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(第一个元素的指针，最后一个元素再后一个元素的指针);</span><br></pre></td></tr></table></figure>

<h2 id="排序-交换"><a href="#排序-交换" class="headerlink" title="排序&amp;交换"></a>排序&amp;交换</h2><p>加上一个交换规则函数comp，不交换return true;否则return false;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(第一个元素的指针，最后一个元素再后一个元素的指针，comp);</span><br></pre></td></tr></table></figure>

<h2 id="加上序号seq变量——-稳定排序"><a href="#加上序号seq变量——-稳定排序" class="headerlink" title="加上序号seq变量——&gt;稳定排序"></a>加上序号seq变量——&gt;稳定排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">    <span class="type">int</span> seq;<span class="comment">//记录数据读入次序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>描述</p>
<p>输入10个整数，彼此以空格分隔。重新排序以后输出(也按空格分隔)，要求: 1.先输出其中的奇数,并按从大到小排列； 2.然后输出其中的偶数,并按从小到大排列。</p>
<p>输入描述：</p>
<p>任意排序的10个整数（0～100），彼此以空格分隔。</p>
<p>输出描述：</p>
<p>可能有多组测试数据，对于每组数据，按照要求排序后输出，由空格分隔。 1. 测试数据可能有很多组，请使用while(cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;…&gt;&gt;a[9])类似的做法来实现; 2. 输入数据随机，有可能相等。</p>
<p>示例1</p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 7 3 13 11 12 0 47 34 98</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">47 13 11 7 3 0 4 12 34 98</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(<span class="type">int</span> lhs, <span class="type">int</span> rhs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不交换顺序:1.大奇数，小奇数 2.小偶数，大偶数 3. 奇数，偶数</span></span><br><span class="line">    <span class="keyword">if</span> (lhs % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; rhs % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; lhs &gt; rhs)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (lhs % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; rhs % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; lhs &lt; rhs)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (lhs % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; rhs % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d%d%d%d%d%d&quot;</span>, arr, arr + <span class="number">1</span>, arr + <span class="number">2</span>, arr + <span class="number">3</span>, arr + <span class="number">4</span>,</span><br><span class="line">                 arr + <span class="number">5</span>, arr + <span class="number">6</span>, arr + <span class="number">7</span>, arr + <span class="number">8</span>, arr + <span class="number">9</span>) != EOF) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr, arr + <span class="number">10</span>, comp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="struct自定义类型"><a href="#struct自定义类型" class="headerlink" title="struct自定义类型"></a>struct自定义类型</h1><p>当一个学生记录既要存储学号，也要存储成绩的时候（即要存储多个信息），用int类型的一维数组并不满足需求，所以若有多个item的时，我们要自定义类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类    类名</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;<span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> grade;<span class="comment">//成绩</span></span><br><span class="line">&#125;;<span class="comment">//分号不能省略</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="动态数组（向量-vector"><a href="#动态数组（向量-vector" class="headerlink" title="动态数组（向量 vector)"></a>动态数组（向量 vector)</h1><h2 id="C风格数组的限制"><a href="#C风格数组的限制" class="headerlink" title="C风格数组的限制"></a>C风格数组的限制</h2><ol>
<li><p>在定义数组时就要固定大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[n]; <span class="comment">//在低版本中这样用变量创建数组是有问题的</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">100</span>];<span class="comment">//必须这样用常量创建</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在内存的栈区中不能过大。</p>
</li>
</ol>
<h2 id="C-风格vector"><a href="#C-风格vector" class="headerlink" title="C++风格vector"></a>C++风格vector</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化vector, 元素全0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="comment">//长度为0</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec1;</span><br><span class="line">    <span class="comment">//尾部扩容</span></span><br><span class="line">    vec<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始化vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec2 &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="comment">//随机插入，删除某个位置</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it=vec<span class="number">2.</span><span class="built_in">begin</span>()<span class="number">+1</span>;</span><br><span class="line">    vec<span class="number">2.</span><span class="built_in">insert</span>(it,<span class="number">4</span>);</span><br><span class="line">    vec<span class="number">2.</span><span class="built_in">erase</span>(vec<span class="number">2.</span><span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=vec<span class="number">2.</span><span class="built_in">begin</span>();it!=vec<span class="number">2.</span><span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾部弹出</span></span><br><span class="line">    vec<span class="number">2.</span><span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">//访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;vec<span class="number">2.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,vec2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列其实就是一个受限的数组，只能在两端操作</p>
<p>循环队列的实现也很简单：先出队pop，再入队push</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//如果队列为空，则返回true</span></span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出队首元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the front of queue is %d\n&quot;</span>,q.<span class="built_in">front</span>());</span><br><span class="line">        <span class="comment">//弹出队首元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈也是一个受限的数组，只能在其一端（栈顶top）进行操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; myStack;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        myStack.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the size of myStack = %d\n&quot;</span>,myStack.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">while</span>(!myStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">//获取栈顶元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,myStack.<span class="built_in">top</span>());</span><br><span class="line">        <span class="comment">//弹栈</span></span><br><span class="line">        myStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the i in fun%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fun</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the i in main() = %d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">the i in <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">2</span></span><br><span class="line"><span class="function">the i in <span class="title">main</span><span class="params">()</span> </span>= <span class="number">1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>可以见到在fun中改变i的值，并不会改变到main中i的值</p>
<p>原因是他们是两个函数，在栈区中开辟两个不同的栈帧，这两个栈帧中都有各自的局部变量i，他们互不影响。</p>
<p>如果我们要在fun函数中，访问main中的i变量，则需要得到main中i的内存地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>* i)</span></span>&#123;</span><br><span class="line">    (*i)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fun</span>(&amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the i in main() = %d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">the i in <span class="title">main</span><span class="params">()</span> </span>= <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>法二：引用</p>
<p>使用引用后，在fun中的i变量其实是在main中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>&#123;<span class="comment">//引用main中的i变量</span></span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fun</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the i in main() = %d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h1><p>如果我们想函数fun中创建链表，就一定要在堆空间创建链表，只有这样我们的链表才不会随栈帧在内存中的释放而消失。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">addNote</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* pNote = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//在堆区中创建一个int变量，返回变量地址</span></span><br><span class="line">    *pNote=i;</span><br><span class="line">    <span class="keyword">return</span> pNote;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        arr[i] = <span class="built_in">addNote</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于堆区中的变量不会主动释放。如果使用new创建变量，就要当我们不用他们的时候，就要delete。如果不去回收堆空间，这种情况就叫内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">delete</span> arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>在线性表的基础上做出改进，由原来的1前驱1后继，变成1前驱2后继(父子关系）。</p>
<p><strong>由于二叉树的结构复杂，不能像顺序表一样在内存中顺序存储，所以我们要采用链式存储：一个区域存放数据，另一个区域存放指针</strong></p>
<img src="https://i.imgur.com/6PKC8bJ.png" style="zoom:67%;">



<h2 id="层次建树"><a href="#层次建树" class="headerlink" title="层次建树"></a>层次建树</h2><p><img src="https://i.imgur.com/wiyAqOP.png"></p>
<p><img src="https://i.imgur.com/VUMMlGh.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="comment">//数据域</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="comment">//指针域</span></span><br><span class="line">    TreeNode *leftChild;</span><br><span class="line">    TreeNode *rightChild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QueueNode</span> &#123;   <span class="comment">//队列的每个结点，存储父亲的位置，以及是否插入过左孩子</span></span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    <span class="type">bool</span> isLeftIn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作需要改变main中的变量，所以要加引用&amp;符号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertTreeNode</span><span class="params">(TreeNode *&amp;root, queue&lt;QueueNode *&gt; &amp;myQueue, <span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//创建二叉树结点，因为是在被调函数内创建，所以要申请堆空间</span></span><br><span class="line">        TreeNode *pTreeNode = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        <span class="comment">//(*pTreeNode).data=data; //注意：*的优先级低于.所以要加()得到Node结点</span></span><br><span class="line">        pTreeNode-&gt;data = data;<span class="comment">//与上一行等价</span></span><br><span class="line">        <span class="comment">//入队，我们就知道新进来的结点是插parent的左边还是右边</span></span><br><span class="line">        QueueNode *pQueueNode = <span class="keyword">new</span> QueueNode;</span><br><span class="line">        pQueueNode-&gt;parent = pTreeNode;</span><br><span class="line">        pQueueNode-&gt;isLeftIn = <span class="literal">false</span>;</span><br><span class="line">        myQueue.<span class="built_in">push</span>(pQueueNode);</span><br><span class="line">        <span class="comment">//插入</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//插入第一个结点</span></span><br><span class="line">            root = pTreeNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入的不是根</span></span><br><span class="line">            <span class="comment">//找到要插入结点的父亲的位置（队头）</span></span><br><span class="line">            QueueNode *pParent = myQueue.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (pParent-&gt;isLeftIn == <span class="literal">false</span>) &#123;</span><br><span class="line">                pParent-&gt;parent-&gt;leftChild = pTreeNode;</span><br><span class="line">                pParent-&gt;isLeftIn = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pParent-&gt;parent-&gt;rightChild = pTreeNode;</span><br><span class="line">                <span class="comment">//出队</span></span><br><span class="line">                myQueue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">delete</span> pParent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//是#，插入NULL</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            QueueNode* pParent=myQueue.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span>(pParent-&gt;isLeftIn == <span class="literal">false</span>)&#123;</span><br><span class="line">                pParent-&gt;parent-&gt;leftChild=<span class="literal">NULL</span>;</span><br><span class="line">                pParent-&gt;isLeftIn= <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pParent-&gt;parent-&gt;rightChild=<span class="literal">NULL</span>;</span><br><span class="line">                myQueue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">delete</span> pParent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode *root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> charList[] = <span class="string">&quot;abc##de#g##f###&quot;</span>;</span><br><span class="line">    queue&lt;QueueNode *&gt; myQueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; charList[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">insertTreeNode</span>(root, myQueue, charList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">levelOrder</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="层次遍历（广度优先——-辅助队列）"><a href="#层次遍历（广度优先——-辅助队列）" class="headerlink" title="层次遍历（广度优先——&gt;辅助队列）"></a>层次遍历（广度优先——&gt;辅助队列）</h2><p>辅助队列：访问起点，把起点的所有邻居加入队列。再按队列访问，把被访问结点的邻居入队。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//辅助队列，存储二叉树结点地址</span></span><br><span class="line">    queue&lt;TreeNode *&gt; pos;</span><br><span class="line">    pos.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!pos.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode *pCur=pos.<span class="built_in">front</span>();</span><br><span class="line">        pos.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,pCur-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(pCur-&gt;leftChild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pos.<span class="built_in">push</span>(pCur-&gt;leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pCur-&gt;rightChild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pos.<span class="built_in">push</span>(pCur-&gt;rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><p>一颗树也可以将大问题转换成小问题。</p>
<p>把树分成三个部分：根，左子树，右子树。（左子树，右子树，分别为小问题）</p>
<p>递归出口：空树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,root-&gt;data);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;leftChild);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(root-&gt;leftChild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,root-&gt;data);</span><br><span class="line">        <span class="built_in">InOrder</span>(root-&gt;rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;leftChild);</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;rightChild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,root-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="已知前中序，求后序"><a href="#已知前中序，求后序" class="headerlink" title="已知前中序，求后序"></a>已知前中序，求后序</h2><p>给定一棵二叉树的前序遍历和中序遍历，求其后序遍历（提示：给定前序遍历与中序遍历能够唯一确定后序遍历）。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/6e732a9632bc4d12b442469aed7fe9ce">https://www.nowcoder.com/questionTerminal/6e732a9632bc4d12b442469aed7fe9ce</a></p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两个字符串，其长度n均小于等于26。</span><br><span class="line">第一行为前序遍历，第二行为中序遍历。</span><br><span class="line">二叉树中的结点名称以大写字母表示：A，B，C....最多26个结点。</span><br></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入样例可能有多组，对于每组测试样例，</span><br><span class="line">输出一行，为后序遍历的字符串。</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ABC</span><br><span class="line">BAC</span><br><span class="line">FDXEAG</span><br><span class="line">XDEFAG</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BCA</span><br><span class="line">XEDGAF</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    TreeNode* lchild;</span><br><span class="line">    TreeNode* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">rebuild</span><span class="params">(string preOrder,string inOrder)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preOrder.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//从先序确定根</span></span><br><span class="line">        <span class="type">char</span> rootdata=preOrder[<span class="number">0</span>];</span><br><span class="line">        TreeNode* pNewNode=<span class="keyword">new</span> TreeNode;</span><br><span class="line">        pNewNode-&gt;data=rootdata;</span><br><span class="line">        <span class="comment">//拿根去切割先序，中序</span></span><br><span class="line">        <span class="type">int</span> pos=inOrder.<span class="built_in">find</span>(rootdata);</span><br><span class="line">        <span class="comment">//preOrder.substr(1,pos)</span></span><br><span class="line">        <span class="comment">//preOrder.substr(pos+1)</span></span><br><span class="line">        <span class="comment">//inOrder.substr(0,pos)</span></span><br><span class="line">        <span class="comment">//inOrder.substr(pos+1)</span></span><br><span class="line">        pNewNode-&gt;lchild= <span class="built_in">rebuild</span>(preOrder.<span class="built_in">substr</span>(<span class="number">1</span>,pos),inOrder.<span class="built_in">substr</span>(<span class="number">0</span>,pos));</span><br><span class="line">        pNewNode-&gt;rchild= <span class="built_in">rebuild</span>(preOrder.<span class="built_in">substr</span>(pos<span class="number">+1</span>),inOrder.<span class="built_in">substr</span>(pos<span class="number">+1</span>));</span><br><span class="line">        <span class="keyword">return</span> pNewNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,root-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> preOrder[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> inOrder[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,preOrder,inOrder)!=EOF)&#123;</span><br><span class="line">        TreeNode* root= <span class="built_in">rebuild</span>(preOrder,inOrder);</span><br><span class="line">        <span class="built_in">postOrder</span>(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="已知带空叶子的先序"><a href="#已知带空叶子的先序" class="headerlink" title="已知带空叶子的先序"></a>已知带空叶子的先序</h2><p>因为先序按（根，左，右）的顺序进行，并且带有空叶子，所以一定能表示出一棵树。</p>
<p>这样也可以采用递归进行构建二叉树。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/4b91205483694f449f94c179883c1fef">https://www.nowcoder.com/questionTerminal/4b91205483694f449f94c179883c1fef</a></p>
<p>编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。  </p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入包括1行字符串，长度不超过100。</span><br></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可能有多组测试数据，对于每组数据，</span><br><span class="line">输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。</span><br><span class="line">每个输出结果占一行。</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc##de#g##f###</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c b e g d f a </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    TreeNode* lchild;</span><br><span class="line">    TreeNode* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TreeNode* <span class="title">RecursiveBuildTree</span><span class="params">(<span class="type">int</span> &amp;i, string str)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c=str[i];</span><br><span class="line">    ++i;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        TreeNode* pNewNode=<span class="keyword">new</span> TreeNode;</span><br><span class="line">        pNewNode-&gt;data=c;</span><br><span class="line">        pNewNode-&gt;lchild= <span class="built_in">RecursiveBuildTree</span>(i,str);</span><br><span class="line">        pNewNode-&gt;rchild= <span class="built_in">RecursiveBuildTree</span>(i,str);</span><br><span class="line">        <span class="keyword">return</span> pNewNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,root-&gt;data);</span><br><span class="line">        <span class="built_in">InOrder</span>(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">150</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf,<span class="number">150</span>,stdin)!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        string str=buf;</span><br><span class="line">        str.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        TreeNode* root= <span class="built_in">RecursiveBuildTree</span>(i,str);</span><br><span class="line">        <span class="built_in">InOrder</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二叉搜索树（BST"><a href="#二叉搜索树（BST" class="headerlink" title="二叉搜索树（BST)"></a>二叉搜索树（BST)</h1><p>左&lt;根&lt;右（左子树和右子树分别又是一颗二次搜索树）</p>
<p>中序是一个有序序列。 </p>
<h2 id="二叉搜索树的查找和插入。"><a href="#二叉搜索树的查找和插入。" class="headerlink" title="二叉搜索树的查找和插入。"></a>二叉搜索树的查找和插入。</h2><p>他的查找过程类似于二分查找。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/30a0153649304645935c949df7599602">https://www.nowcoder.com/questionTerminal/30a0153649304645935c949df7599602</a></p>
<p>二叉排序树，也称为二叉查找树。可以是一颗空树，也可以是一颗具有如下特性的非空二叉树： 1. 若左子树非空，则左子树上所有节点关键字值均不大于根节点的关键字值； 2. 若右子树非空，则右子树上所有节点关键字值均不小于根节点的关键字值； 3. 左、右子树本身也是一颗二叉排序树。 现在给你N个关键字值各不相同的节点，要求你按顺序插入一个初始为空树的二叉排序树中，每次插入后成功后，求相应的父亲节点的关键字值，如果没有父亲节点，则输出-1。                                        </p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入包含多组测试数据，每组测试数据两行。</span><br><span class="line">第一行，一个数字N（N&lt;=100），表示待插入的节点数。</span><br><span class="line">第二行，N个互不相同的正整数，表示要顺序插入节点的关键字值，这些值不超过10^8。</span><br></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出共N行，每次插入节点后，该节点对应的父亲节点的关键字值。</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 5 1 3 4</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> data;</span><br><span class="line">    TreeNode *lchild;</span><br><span class="line">    TreeNode *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertBST</span><span class="params">(TreeNode *&amp;root, <span class="type">long</span> <span class="type">long</span> data)</span> </span>&#123;</span><br><span class="line">    TreeNode *pNewNode = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    pNewNode-&gt;data = data;</span><br><span class="line">    pNewNode-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    pNewNode-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = pNewNode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode *pPre = root;</span><br><span class="line">        TreeNode *pCur;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; pPre-&gt;data) &#123;    <span class="comment">//比pPre小就往左走</span></span><br><span class="line">                pCur = pPre-&gt;lchild;</span><br><span class="line">                <span class="keyword">if</span> (pCur == <span class="literal">NULL</span>) &#123; <span class="comment">//判断左边为空，就直接插入</span></span><br><span class="line">                    pPre-&gt;lchild = pNewNode;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, pPre-&gt;data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;         <span class="comment">//不为空，就往下移动</span></span><br><span class="line">                    pPre = pCur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;              <span class="comment">//pCur比pPre大就往右走</span></span><br><span class="line">                pCur = pPre-&gt;rchild;</span><br><span class="line">                <span class="keyword">if</span> (pCur == <span class="literal">NULL</span>) &#123; <span class="comment">//为空，就插入</span></span><br><span class="line">                    pPre-&gt;rchild = pNewNode;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, pPre-&gt;data);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;           <span class="comment">//不为空，就往下移动</span></span><br><span class="line">                    pPre = pCur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;num);</span><br><span class="line">        <span class="built_in">insertBST</span>(root,num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优先队列（大根堆）"><a href="#优先队列（大根堆）" class="headerlink" title="优先队列（大根堆）"></a>优先队列（大根堆）</h1><p>应用：在一个动态的队列中，不断去得到最大值。</p>
<p>一个大根堆要满足两个特征：</p>
<p>形状特征：由大根堆是完全二叉树（由结点的个数，就能确定一个二叉树的形状），所以我们不再采用链式存储，而采用顺序存储。</p>
<p>数值特征：父&gt;左，父&gt;右（根最大）</p>
<h2 id="大根堆删除"><a href="#大根堆删除" class="headerlink" title="大根堆删除"></a>大根堆删除</h2><ol>
<li>最大值先出队。其位置于堆尾结点交换。</li>
<li>小元素不断下坠（如其比两个孩子的最大值更小，就跟两个孩子的最大值交换）</li>
</ol>
<p>所以大根堆出堆顶的时间复杂的<code>O(log n)</code>(因为最坏的情况下，在下坠的过程中，交换log n 次，而完全二叉树的高度h约&#x3D;logn)</p>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; myPQueue;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        myPQueue.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!myPQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,myPQueue.<span class="built_in">top</span>());</span><br><span class="line">        myPQueue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The priority queue is empty.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构建小根堆"><a href="#构建小根堆" class="headerlink" title="构建小根堆"></a>构建小根堆</h2><p>法1：取巧的方案（只适用于全部都是正数）</p>
<p>先把数组全变成负数。然后push到priority_queue，等到top取出元素的时候，我们才把他变为正数。</p>
<p>法2：运算符重载（但只支持自定义类型运算符重载）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Element</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//运算符重载（跟函数的构造很像）</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(Element lhs,Element rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.value &gt; rhs.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;Element&gt; pQueue;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        Element e;</span><br><span class="line">        e.value=arr[i];</span><br><span class="line">        pQueue.<span class="built_in">push</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><ol>
<li><p>把所有结点加入集合中（集合要使用小根堆）</p>
</li>
<li><p>若k的size&gt;1，</p>
<p>取出权重最小的两个结点，并求和，放回集合中</p>
</li>
<li><p>若k集合中只剩下一个元素，那么就是树的根</p>
</li>
</ol>
<p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/162753046d5f47c7aac01a5b2fcda155">https://www.nowcoder.com/questionTerminal/162753046d5f47c7aac01a5b2fcda155</a></p>
<p>哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有结点的值与权值的乘积之和的最小值。                               </p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入有多组数据。</span><br><span class="line">每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2&lt;=n&lt;=1000）。</span><br></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出权值。</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5  </span><br><span class="line">1 2 2 5 9</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pQueue;     <span class="comment">//存入相反数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> num;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">            pQueue.<span class="built_in">push</span>(-num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;      <span class="comment">//存储带权路径和的中间结果</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>&lt;pQueue.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> num1=pQueue.<span class="built_in">top</span>();</span><br><span class="line">            pQueue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> num2=pQueue.<span class="built_in">top</span>();</span><br><span class="line">            pQueue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//计算带权路径和 = L的带权路径和 + L的叶子权重和 + R的带权路径和 + R的叶子权重和</span></span><br><span class="line">            res=res+num1+num2;</span><br><span class="line"></span><br><span class="line">            pQueue.<span class="built_in">push</span>(num1+num2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,-res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="广度优先（BFS）"><a href="#广度优先（BFS）" class="headerlink" title="广度优先（BFS）"></a>广度优先（BFS）</h2><p>优先转移到所有的邻居，由于要存储邻居，我们要设置辅助队列。由于，要记录已经被访问过的结点，要设置一个辅助集合isVisit</p>
<p>用途：求最优解</p>
<h1 id="Catch-That-Cow"><a href="#Catch-That-Cow" class="headerlink" title="Catch That Cow"></a>Catch That Cow</h1><p>Description</p>
<p>Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.</p>
<p>Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minute<br>Teleporting: FJ can move from any point X to the point 2 × X in a single minute.<br>If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?</p>
<p>Input</p>
<p>Line 1: Two space-separated integers: N and K<br>Output</p>
<p>Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.<br>Sample Input</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 17</span><br></pre></td></tr></table></figure>


<p>Sample Output</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>可以知道，本题是一个最优解问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    queue&lt;Info&gt; posQueue;</span><br><span class="line">    <span class="type">bool</span> isVisit[<span class="number">100001</span>];   <span class="comment">//记录该结点是否被访问过</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100001</span>;i++)&#123;</span><br><span class="line">        isVisit[i]= <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info first;</span><br><span class="line">    first.pos=n;</span><br><span class="line">    first.time=<span class="number">0</span>;</span><br><span class="line">    posQueue.<span class="built_in">push</span>(first);</span><br><span class="line">    <span class="keyword">while</span> (!posQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Info cur=posQueue.<span class="built_in">front</span>();</span><br><span class="line">        posQueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur.pos==k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cur.time);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isVisit[cur.pos]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//把邻居加入队列</span></span><br><span class="line">        Info neighbor;</span><br><span class="line">        <span class="keyword">if</span>(cur.pos<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; cur.pos<span class="number">-1</span>&lt;=<span class="number">100000</span> &amp;&amp; isVisit[cur.pos<span class="number">-1</span>]== <span class="literal">false</span>)&#123;</span><br><span class="line">            neighbor.pos=cur.pos<span class="number">-1</span>;</span><br><span class="line">            neighbor.time=cur.time<span class="number">+1</span>;</span><br><span class="line">            posQueue.<span class="built_in">push</span>(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.pos<span class="number">+1</span>&gt;=<span class="number">0</span> &amp;&amp; cur.pos<span class="number">+1</span>&lt;=<span class="number">100000</span> &amp;&amp; isVisit[cur.pos<span class="number">+1</span>]== <span class="literal">false</span>)&#123;</span><br><span class="line">            neighbor.pos=cur.pos<span class="number">+1</span>;</span><br><span class="line">            neighbor.time=cur.time<span class="number">+1</span>;</span><br><span class="line">            posQueue.<span class="built_in">push</span>(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.pos*<span class="number">2</span>&gt;=<span class="number">0</span> &amp;&amp; cur.pos*<span class="number">2</span>&lt;=<span class="number">100000</span> &amp;&amp; isVisit[cur.pos*<span class="number">2</span>]== <span class="literal">false</span>)&#123;</span><br><span class="line">            neighbor.pos=cur.pos*<span class="number">2</span>;</span><br><span class="line">            neighbor.time=cur.time<span class="number">+1</span>;</span><br><span class="line">            posQueue.<span class="built_in">push</span>(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Find The Multiple</p>
<ul>
<li><p>描述	</p>
<p>Given a positive integer n, write a program to find out a nonzero multiple m of n whose decimal representation contains only the digits 0 and 1. You may assume that n is not greater than 200 and there is a corresponding m containing no more than 100 decimal digits.</p>
</li>
<li><p>输入</p>
<p>The input file may contain multiple test cases. Each line contains a value of n (1 &lt;&#x3D; n &lt;&#x3D; 200). A line containing a zero terminates the input.</p>
</li>
<li><p>输出</p>
<p>For each value of n in the input print a line containing the corresponding value of m. The decimal representation of m must not contain more than 100 digits. If there are multiple solutions for a given value of n, any one of them is acceptable.</p>
</li>
<li><p>样例输入</p>
<p><code>2 6 19 0</code></p>
</li>
<li><p>样例输出</p>
<p><code>10 100100100100100100 111111111111111111</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">long</span> <span class="type">long</span>&gt; m;</span><br><span class="line">        m.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!m.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> cur=m.<span class="built_in">front</span>();</span><br><span class="line">            m.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(cur%n==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,cur);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m.<span class="built_in">push</span>(cur*<span class="number">10</span>);</span><br><span class="line">            m.<span class="built_in">push</span>(cur*<span class="number">10</span><span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="深度优先-DFS"><a href="#深度优先-DFS" class="headerlink" title="深度优先(DFS)"></a>深度优先(DFS)</h2><p>优先使用递归，去重：辅助结合isVisit。路径：Stack</p>
<p>A Knight’s Journey</p>
<p>描述</p>
<p><img src="http://media.openjudge.cn/images/g1490/2488_1.jpg" alt="img"><strong>Background</strong><br>The knight is getting bored of seeing the same black and white squares again and again and has decided to make a journey around the world. Whenever a knight moves, it is two squares in one direction and one square perpendicular to this. The world of a knight is the chessboard he is living on. Our knight lives on a chessboard that has a smaller area than a regular 8 * 8 board, but it is still rectangular. Can you help this adventurous knight to make travel plans?</p>
<p><strong>Problem</strong><br>Find a path such that the knight visits every square once. The knight can start and end on any square of the board.</p>
<p>输入</p>
<p>The input begins with a positive integer n in the first line. The following lines contain n test cases. Each test case consists of a single line with two positive integers p and q, such that 1 &lt;&#x3D; p * q &lt;&#x3D; 26. This represents a p * q chessboard, where p describes how many different square numbers 1, . . . , p exist, q describes how many different square letters exist. These are the first q letters of the Latin alphabet: A, . . .</p>
<p>输出</p>
<p>The output for every scenario begins with a line containing “Scenario #i:”, where i is the number of the scenario starting at 1. Then print a single line containing the lexicographically first path that visits all squares of the chessboard with knight moves followed by an empty line. The path should be given on a single line by concatenating the names of the visited squares. Each square name consists of a capital letter followed by a number.<br>If no such path exist, you should output impossible on a single line.</p>
<p>样例输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>

<p>样例输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scenario #1:</span><br><span class="line">A1</span><br><span class="line"></span><br><span class="line">Scenario #2:</span><br><span class="line">impossible</span><br><span class="line"></span><br><span class="line">Scenario #3:</span><br><span class="line">A1B3C1A2B4C2A3B1C3A4B2C4</span><br></pre></td></tr></table></figure>









</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://ferrychan666.github.io">FerryChan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://ferrychan666.github.io/2023/02/16/cpp/Basic%20syntax/">http://ferrychan666.github.io/2023/02/16/cpp/Basic%20syntax/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cpp/">cpp</a></div><div class="post-share"><div class="social-share" data-image="/img/Tom.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/02/10/JavaScript/jQuery/" title="jQuery"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">jQuery</div></div><div class="info-2"><div class="info-item-1">jQuery IntroductionjQuery is a JavaScript Library. jQuery greatly simplifies JavaScript programming. jQuery also simplifies a lot of the complicated things from JavaScript, like AJAX calls and DOM manipulation. The jQuery library contains the following features:  HTML&#x2F;DOM manipulation CSS manipulation HTML event methods Effects and animations AJAX Utilities  Tip: In addition, jQuery has plugins for almost any task out there. jQuery SyntaxThe jQuery syntax is tailor-made for selecting...</div></div></div></a><a class="pagination-related" href="/2023/03/17/Python/Tkinter/" title="Tkinter"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Tkinter</div></div><div class="info-2"><div class="info-item-1">IntroductionThe foundational element of a Tkinter GUI is the window. Windows are the containers in which all other GUI elements live. These other GUI elements, such as text boxes, labels, and buttons, are known as widgets. windowThe first thing you need to do is import the Python GUI Tkinter module: 1import tkinter as tk  A window is an instance of Tkinter’s Tk class. Go ahead and create a new window and assign it to the variable window: 1window = tk.Tk()  widgetsUse the tk.Label class to...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/11/29/cpp/OOP/" title="OOP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-29</div><div class="info-item-2">OOP</div></div><div class="info-2"><div class="info-item-1">C++ OOPOOP stands for Object-Oriented Programming. Procedural programming is about writing procedures or functions that perform operations on the data, while object-oriented programming is about creating objects that contain both data and functions.   OOP is faster and easier to execute OOP provides a clear structure for the programs OOP helps to keep the C++ code DRY “Don’t Repeat Yourself“, and makes the code easier to maintain, modify and debug OOP makes it possible to create full...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/Tom.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">FerryChan</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/FerryChan666" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#string"><span class="toc-number">1.</span> <span class="toc-text">string</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#User-Input-Strings"><span class="toc-number">1.1.</span> <span class="toc-text">User Input Strings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Omitting-Namespace"><span class="toc-number">1.2.</span> <span class="toc-text">Omitting Namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.3.</span> <span class="toc-text">C风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.4.</span> <span class="toc-text">C++风格</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#map-%E6%98%A0%E5%B0%84"><span class="toc-number">2.</span> <span class="toc-text">map(映射)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8map%E4%BB%A3%E6%9B%BF%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.</span> <span class="toc-text">用map代替二分查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sort"><span class="toc-number">3.</span> <span class="toc-text">sort</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">排序&amp;交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E4%B8%8A%E5%BA%8F%E5%8F%B7seq%E5%8F%98%E9%87%8F%E2%80%94%E2%80%94-%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="toc-number">3.2.</span> <span class="toc-text">加上序号seq变量——&gt;稳定排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#struct%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">struct自定义类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%88%E5%90%91%E9%87%8F-vector"><span class="toc-number">5.</span> <span class="toc-text">动态数组（向量 vector)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E9%A3%8E%E6%A0%BC%E6%95%B0%E7%BB%84%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">5.1.</span> <span class="toc-text">C风格数组的限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E9%A3%8E%E6%A0%BCvector"><span class="toc-number">5.2.</span> <span class="toc-text">C++风格vector</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">7.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">指针和引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="toc-number">9.</span> <span class="toc-text">堆空间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">10.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%BB%BA%E6%A0%91"><span class="toc-number">10.1.</span> <span class="toc-text">层次建树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E2%80%94%E2%80%94-%E8%BE%85%E5%8A%A9%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">层次遍历（广度优先——&gt;辅助队列）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">10.3.</span> <span class="toc-text">递归遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E5%89%8D%E4%B8%AD%E5%BA%8F%EF%BC%8C%E6%B1%82%E5%90%8E%E5%BA%8F"><span class="toc-number">10.4.</span> <span class="toc-text">已知前中序，求后序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E5%B8%A6%E7%A9%BA%E5%8F%B6%E5%AD%90%E7%9A%84%E5%85%88%E5%BA%8F"><span class="toc-number">10.5.</span> <span class="toc-text">已知带空叶子的先序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88BST"><span class="toc-number">11.</span> <span class="toc-text">二叉搜索树（BST)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8F%92%E5%85%A5%E3%80%82"><span class="toc-number">11.1.</span> <span class="toc-text">二叉搜索树的查找和插入。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%A4%A7%E6%A0%B9%E5%A0%86%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">优先队列（大根堆）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%A0%B9%E5%A0%86%E5%88%A0%E9%99%A4"><span class="toc-number">12.1.</span> <span class="toc-text">大根堆删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priority-queue"><span class="toc-number">12.2.</span> <span class="toc-text">priority_queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%B0%8F%E6%A0%B9%E5%A0%86"><span class="toc-number">12.3.</span> <span class="toc-text">构建小根堆</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">13.</span> <span class="toc-text">哈夫曼树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">14.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%EF%BC%88BFS%EF%BC%89"><span class="toc-number">14.1.</span> <span class="toc-text">广度优先（BFS）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Catch-That-Cow"><span class="toc-number">15.</span> <span class="toc-text">Catch That Cow</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88-DFS"><span class="toc-number">15.1.</span> <span class="toc-text">深度优先(DFS)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1cookies%E5%85%8D%E7%99%BB%E5%BD%95/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1cookies%E5%85%8D%E7%99%BB%E5%BD%95/" title="记录一次cookies免登录">记录一次cookies免登录</a><time datetime="2025-02-17T18:04:11.000Z" title="Created 2025-02-18 02:04:11">2025-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/16/scrapy/scrapy/" title="scrapy">scrapy</a><time datetime="2025-02-16T08:49:35.000Z" title="Created 2025-02-16 16:49:35">2025-02-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/15/%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/" title="在终端中配置代理">在终端中配置代理</a><time datetime="2025-02-15T13:50:58.000Z" title="Created 2025-02-15 21:50:58">2025-02-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/15/scrape/JavaScript%E5%8F%8D%E7%88%AC%E8%99%AB%E5%8E%9F%E7%90%86/" title="JavaScript反爬虫原理">JavaScript反爬虫原理</a><time datetime="2025-02-15T07:16:34.000Z" title="Created 2025-02-15 15:16:34">2025-02-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/19/Q&amp;A/pip-install-%E6%8C%82%E4%BB%A3%E7%90%86/" title="pip install 挂代理">pip install 挂代理</a><time datetime="2023-04-19T14:54:54.000Z" title="Created 2023-04-19 22:54:54">2023-04-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By FerryChan</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>